% !TeX spellcheck = de_DE
\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

Dit hoofdstuk bevat de literatuurstudie omtrent het onderwerp. Hier wordt de architectuur en de termen uitgelegd. Daarnaast zal hier een vergelijking gemaakt worden tussen onderdelen van microservices. Tenslotte zal hier een beeld van een order-to-cash proces gemaakt worden.

\section{Microservices}
\subsection{Definitie}
Aangezien de term monolithic veelvuldig zal gebruikt worden, zal er bij aanvang reeds een beeld scheppen omtrent de term:  'Monolithic software is designed to be self-contained; components of the program are interconnected and interdependent rather than loosely coupled as is the case with ' software programs.',  \textcite{Wigmore2016}.
Om te begrijpen waarom een overschakeling naar microservices een goed idee is, worden de de moeilijkheden bij monolithic architectuur aangehaald. Bij een verandering binnen een monolithic architectuur, wordt een geheel nieuwe  versie hiervan uitgebracht. Dit creëert een aanzienlijke overhead. Met architectuur wordt de algemene manier van implementatie bedoeld. Bij het gebruik van het woord architectuur, wordt er niet verwezen naar de applicatie maar de achterliggende logica ervan.
De overschakeling naar microservice omvat onder andere
\begin{itemize}
	\item De volledige architectuur moet opnieuw getest worden.
	\item Deze architectuur kan heel complex worden bij het toevoegen van functionaliteiten.
	\item De complete architectuur moet opnieuw gedeployed worden bij elke update.
	\item De impact van een verandering kan verkeerd ingeschat worden.
	\item Bij een fout in een proces, kan de volledige architectuur falen.
\end{itemize}
Er zijn meerdere definities terug te vinden over microservices. In volgende opsomming kunnen enkele definities gevonden worden:
\begin{itemize}
	\item 'A method of developing software applications as a suite of independently deployable, small, services in which each service runs a unique process and communicates through a  well-defined, light weight mechanism to serve a business goals.', \textcite{Mauersberger2017}
	\item 'A software architecting pattern that allows software to be developed into relatively small, distinct components. Each of the components is abstracted by an API(s) and provides a distinct subset of the functionality of the entire application.', \textcite{Watts2018}
	\item 'microservices stems from the same ideology as Agile and DevOps by seeking to break down slow moving, monolithic systems into multiple small, independent services that are highly decoupled and self-contained to focus on a specific function or capability.', \textcite{Benetis2016a}
\end{itemize}
 Wanneer men de definities herleest, zijn er enkele terugkerende onderdelen aanwezig. Een eerste onderdeel spitst zich toe op de  werking van een microservice. Het is een onafhankelijke, kleine, modulaire service. Modulaire services zijn services waarbij veel delen uitwisselbaar zijn met diverse services. Wordt er info gestuurd of gevraagd van services A dan zal dit geen invloed hebben op de andere services. Een tweede eigenschap is de eenvoudig communicatie. Er is nood aan omdat sommige services data moeten uitwisselen om hun 'job' te kunnen doen. De communicatie kan gebeuren op verschillende manieren. De manier die gekender is, is 'Messaging via a Message Broker'. Dit wil zeggen dat microservice A een bericht plaatst op de wachtrij bij microservice B wanneer die data wil doorsturen. Dan kan microservices B aan die data wanneer hij die nodig heeft. Ze zullen soms moeten wachten maar ze zijn zo goed als onafhankelijk van elkaar. De derde eigenschap omvat dat een microservice wordt gemaakt in functie van een requirement uit de business. Elk product in de business heeft een doel dat moet voldoen aan eisen. Het unieke aan microservices is dat  men  ze gaat bekijken vanuit de eisen binnen de business. Het doel van microservices is, de problemen die te vinden zijn bij een monolithic, verhelpen. 
 
 De verschillen tussen een monolithic en microservices kunnen het best afgebeeld worden in een afbeelding 2.1.

\begin{figure}[h]
	\includegraphics[width=10cm]{microservices-vs-monolithic.jpg}
	\centering
	\caption{Een monolithic architectuur naast een microservice architectuur. \textcite{Watts2018}}
\end{figure}
 De monolithic wordt  weergegeven in de linkerkant van de foto. Aan de rechterkant van de foto is een voorbeeld te zien van een microservice architectuur. Daar is duidelijk te zien dat elke microservice een eigen databank/datastore heeft. 
 Als bij microservice A een probleem is dan heeft dit niet meteen impact op de andere services. De communicatie tussen microservice A en de anderen zullen hier echter wel hinder ondervinden. Maar de andere microservices kunnen wel nog steeds onafhankelijk verder. 
 Hier ziet men het punt passeren dat een microservice een klein component is van een groter geheel.
 Er is een mogelijkheid van de software om mee te groeien als het aantal gebruikers vermeerderd. De software moet nog even goed presteren bij 10 gebruikers als bij 2 000 gebruikers. Er wordt toegelicht hoe belangrijk API's zijn binnen een microservice architectuur. API's zijn een set van definities die ervoor zorgen dat deeltjes in een programma met elkaar kunnen communcieren. Een voordeel van API's is dat je niet moet  weten hoe de andere code werkt.

 Op figuur 2.2 ziet men dat de monolithic alle puntjes in een kader heeft. Dit staat symbolisch voor het grote geheel dat eigen is aan een monolithic. Alles zit samen in één grote doos. Maar bij microservices is dit niet zo, daar zit elk deeltje/requirement in een aparte doos, \textcite{Benetis2016a} . 
\begin{figure}[h]
	\includegraphics[width=10cm]{Mono_Micro.png}
	\centering
	\caption{Een monolithic vergeleken met een microservice. \textcite{Benetis2016a}}
\end{figure}


Een voorbeeld van een algemene architectuur is te zien op figuur 2.3.
\begin{figure}[h]
	\includegraphics[width=10cm]{algArch.png}
	\centering
	\caption{Een algemene architectuur voor microservices. \textcite{Koukia2018}}
\end{figure}
Deze afbeelding zal naar het einde van de stand van zaken duidelijk zijn.


\subsection{Het belang van microservices}
Microservices zijn van belang wanneer de monolithic architectuur niet meer optimaal werkt. Microservices hebben nauwelijks invloed op het framework als er deeltjes bij gecodeerd worden. Ze kunnen sneller inspelen op de Agile analyse/ontwikkelsmethode. De analyse methode Agile werkt met periodieke opleveringen, die kunnen gaan van twee weken tot een maand. In de periode wordt er gewerkt aan een functionaliteit of een eis van de klant. 
Er voor zorgen dat software schaalbaar is, is een belangrijk punt en daar spelen microservices goed op in.


Enkele andere redenen om microservices te gebruiken volgens \textcite{Koukia2018}, zijn volgende:
\begin{itemize}
	\item Het is gemakkelijker om kleine services te onderhouden. Bij een monolithic is alles één groot geheel, als daar een deeltje van moet worden uitgelegd, kan je verdwalen in het grote geheel. Dit is niet het geval bij microservices. Want elke service is afgebakend met een functionaliteit. Bij het uitleggen van een service kan er duidelijk aangetoond worden waar een services begint en eindigt. 
	\item Een microservices kan onafhankelijk gedeployed worden. Eens een microservices klaar is om gebruikt te worden, moet er naar niets anders gekeken worden. Bij het deeltje definitie  werd hier dieper op ingegaan.
	\item Gemakkelijker aan te passen aan nieuwe  technologie. Komt er een nieuwe  technologie uit die kan toegepast worden op een paar microservices, dan moeten enkel die microservices herschreven worden. Dit is anders bij een monolithic. Als er een nieuwe  technologie is die kan toegepast worden op onderdelen van het geheel, moet de gehele architectuur herschreven worden.
	\item Het is eenvoudiger om te schalen. Schalen gebeurt door een microservice te dupliceren. Niet het gehele systeem moet geschaald worden, enkel de nodige microservices moeten gedupliceerd worden. Het dupliceren van een microservice wil zeggen, de microservice kopiëren en in een ander onderdeel gebruiken. Een microservice dat gedupliceerd kan worden, is dat van logging. 
	\item No single point of failure. Faalt er een microservices in het uitvoeren van zijn functionaliteit, dan heeft dit geen invloed op de andere services. Hier is dieper op ingegaan in de definitie.
	\item Freedom of technology stack choices. Dit omvat dat elk team kan kiezen in  welke programmeertaal ze de microservices schrijven. Een team is verantwoordelijk voor één microservices. Ze zijn dus gespecialiseerd in die ene service. 
	\item De evolutie en de oplevering van business features is sneller. Dit komt door de onafhankelijkheid van de services. Er kan op het zelfde moment aan verschillende services gewerkt worden, zonder elkaar te beïnvloeden.
\end{itemize}


Onder volgende deeltjes wordt er dieper ingegaan op de authenticatie en authorisatie, het verband met Agile en Devops, het debuggen binnen microservices en de bescherming van microservices.

\subsubsection{De verschillende manieren van bescherming}
'Microservices moeten een doel in de business vervullen. Naast dit, zorgen microservices er voor dat de bescherming eenvoudiger wordt.', \textcite{RDX2016}.

De term bescherming omvat volgende: Er voor zorgen dat hackers de applicatie niet kapot maken.
Hackers zijn mensen die inbreken op een applicatie.

Enkele tips om de bescherming van microservices aan te pakken, \textcite{Matteson2017}, \textcite{Silva2017}:
\begin{itemize}
	\item Zorg bij het ontwikkelen van microservices voor coderingsstandaarden die herbruikt kunnen worden. Door eenmaal een goede code te voorzien wordt de kans op kwetsbaarheden en gaten in de bescherming kleiner.
	\item Ga na  welke schade er kan toegebracht worden aan een microservice als die zonder bescherming zou worden geüpload.
	\item Maak gebruik van toegangscontroles. Zorg ervoor dat er gewerkt wordt met leesrechten. Een microservice dat de aankooporders ophaalt moet niet aan de verkooporders kunnen.
	\item Ga geen beveiligingsprincipes gebruiken van externen, implementeer deze in de code van de microservice.
	\item Zorg voor goede documentatie van elke microservice. Dit kan handig zijn bij het ontdekken van een zwak punt in de bescherming. De documentatie kan mogelijke problemen verduidelijken.
	\item Maak een API gateway. Wat het precies allemaal doet wordt verder nog uitgelegd.
	\item Zorg ervoor dat enkel de API gateway zichtbaar is en dat alle data onleesbaar moet worden verzonden. Dit kan gebeuren aan de hand van SSL of TSL. Wat SSL is wordt verder in deze thesis uitgelegd. 
	\item Zorg voor garantie op data privacy. In Europa is de GDPR een  wetgeving die zegt wat er  wel en niet mag gebeuren met mensen hun data. Daarom is het belangrijk dat er gebruik wordt gemaakt van een beveiligd protocol. Op elk level moet er gezorgd worden voor een correcte beveiliging van de gebruikers hun data. 
	\item Voor het encrypteren van data, wordt er best gebruik gemaakt van al bestaande techonologieën . 
	\item Zorg ervoor dat er geen denial of service kan gebeuren. Denail of service komt voor wanneer er heel veel requests naar de applicatie worden gestuurd, waardoor de applicatie faalt. Maak gebruik van throtteling. De term wordt na deze opsomming verder uitgelegd.
	\item Maak gebruik van Cross-site request forgery (CSRF) en Cross-origin resource sharing (CORS) filters. Cross-site request forgery is een poging tot hacken waarbij de eindgebruiker gedwongen wordt om acties te doen terwijl hij geauthenticeerd is. Cross-origin resource sharing laat toe dat er requests van een ander domein kunnen worden gemaakt. 
	\item De API gateway kan goed beschermd zijn, zorg eveneens voor goede bescherming aan de code. Zorg ervoor dat er niks moet worden gerund als administrator, geef duidelijke namen en maak duidelijke afspraken. Enkel de nodige personen mogen de juiste permissies krijgen. 
\end{itemize}

\textcite{Troisi2019} geeft acht best practices over de bescherming van microservices. 
De best practices:
\begin{itemize}
	\item Het gebruik van OAuth voor gebruikers identificatie en wat de gebruiker kan. OAuth/OAuth2 is een protocol voor authorisatie. Het is een gemak om gebruik te maken van een protocol. Een protocol zijn een aantal regels om te communiceren tussen computers. 
	\item Gebruik bescherming in de diepte om een prioriteit toe te kennen aan service keys.  Dit kan verwoord worden als bescherming steken in verschillende lagen van een systeem. Er moet worden nagegaan  welke deeltjes het kwetsbaarst zijn en daar dan op verschillende lagen van beveiliging op toepassen. 
	Microservices maken het toepassen van deze methode, eenvoudiger. Doordat er gefocust kan worden op beveiliging. Het framework maakt het gemakkelijker om de verschillende lagen vast te stellen. Als ze binnen zijn bij een van de microservices zijn ze niet binnen in het volledige systeem. 
	\item Schrijf zelf geen krypto code. Er zijn genoeg open source alternatieven. Enkel bij heel uitzonderlijke redenen wordt een eigen krypto code geschreven. 
	\item Update je bescherming tijdig. Als er updates komen in de software van beveiliging, moeten die ' uitgevoerd worden. Het automatiseren van die updates, kan veel  werk besparen achteraf. Dit wordt dan ' best gedaan bij het begin van microservices. Bescherming binnen software is niet langer meer een nice to have maar een must have. 
	\item Maak gebruik van een firewall met gecentraliseerde controle. Het biedt onder andere meer controle aan de gebruiker.
	\item Zorg dat je 'containers' niet in een publiek net werk te vinden zijn. Dit is eigenlijk zorgen dat gebruikers je achterliggende architectuuur niet kunnen zien. Hier kan een vorige manier ' bijgestoken worden. Microservices kunnen ondergebracht worden achter een firewall als vorm van berscherming.  Als er met containers wordt gewerkt, moet er ' beschemring aanwezig zijn. Een container is een plek waar kleine deeltjes code kunnen op gedeployed worden. 
	\item Maak gebruik van software om virussen te vinden.
	\item Monitor alles.
\end{itemize}

Throtteling, \textcite{Cavalcanti2018}, is een manier van bescherming die het volgende beschrijft: 'Throttling is a process used to control the usage of APIs by consumers during a given period.'. Het kan zijn dat de gebruiker heel veel requests stuurt naar de API gateway. Dit kan zorgen voor een bug door een oneidig aantal requests. Om dit te voorkomen kan er een limiet binnen een bepaalde periode opgelegd worden. Bijvoorbeeld als je je toegangscode drie maal fout hebt op je gsm, dan blokkeert die voor een bepaalde tijd. Het systeem zo ontwerpen dat het bestand is tegen fouten en falen. Met bestand zijn tegen, wordt bedoelt om ervoor te zorgen dat bij een bug of een fout, deze goed wordt opgevangen zodat de gebruiker er geen last van heeft. 

Eén van de meer bekendere manieren is, API gateway. De verantwoordelijkheden van een API gateway zijn volgende, \textcite{Siraj2017}:
\begin{itemize}
	\item Het ontvangen van request van gebruikers.
	\item De requests doorsturen naar de correcte microservice.
	\item Het 'antwoord' van de microservice in ontvangst nemen en doorsturen naar de gebruiker.
\end{itemize}
Zoals te zien is op figuur 2.4, is een API gateway het toegangspunt. Om via de API gateway requests te kunnen maken, moet er eerst authenticatie en authorisatie toegepast worden. Meer uitleg hierover in de sectie over authenticatie en authorisatie.
\begin{figure}[h]
	\includegraphics[width=10cm]{apiGateway_facadePattern.png}
	\centering
	\caption{Een voorstelling van API gateway. \textcite{Siraj2017}}
\end{figure}


\subsubsection{Authenticatie en authorisatie}
Een belangrijk aspect van microservices is de authenticatie en de authorisatie.  Het is een moeilijkheid om op een uniforme manier veiligheid, bescherming, authorisatie en authenticatie toe te passen op microservices, \textcite{Ayoub2018}. Authenticatie het bevestigen van de identiteit van de gebruiker. Dit wordt doorgaans gedaan door middel van een gebruikersnaam en een wachtwoord. Authorisatie is wat je kan doen met een programma. Bijvoorbeeld een beheerder van een site kan meer dan een bezoeker. 
\begin{figure}[h]
	\includegraphics[width=10cm]{monolithic_auth.png}
	\centering
	\caption{Een diagram van authenticatie bij een monolithic. \textcite{Ayoub2018}}
\end{figure}
Zoals te zien is op bovenstaande afbeelding, figuur 2.4, wordt de authenticatie afgehandeld binnen het monlithic proces. Wanneer de gebruiker inlogt, wordt de beveiligings module aangesproken. Deze kijkt of de gebruiker een bekende is, of er al gegevens in de databank zitten. Als het aanmelden gelukt is, wordt er een sessie gecreëerd. Een sessie wordt opgeslaan aan de hand van tokens. Tokens worden op je computer geplaatst door je browser. Het zijn kleine tekstbestanden. De sessie onthoudt wie je bent aan de hand van een ID. Dit zorgt ervoor dat je je niet elke keer opnieuw moet aanmelden als je van pagina verandert.  Elke keer dat de bezoeker van de site iets doet, wordt de sessie ID samen gestuurd met de request. Een request is een aanvraag. Als het ID correct is,  weet de site dat de gebruiker ingelogd is. Bij elke aanvraag wordt de ID meegestuurd zodat er kan gecontroleerd worden of die zo wordt de authenticatie bij een monolithic afgehandeld.
Wanneer er gekeken wordt om authenticatie toe te passen bij microservices, komen volgende puntjes veel voor:
\begin{itemize}
	\item In elke microcservice moet er authenticatie en authorisatie afgehandeld worden. Het beste wordt dit toegepast op een uniforme manier. Dan gaat men er van uit dat er in elke microservices een stukje code gaat komen dat herbruikt wordt. Maar dit zorgt ervoor dat elke microservice toch afhankelijk is. Bij het uitkomen van een nieuwe  versie, moet dit deeltje dan  weer geüpdate worden. Dit heeft invloed op de flexibiliteit van het framework.
	\item 'Single responsibility' zijn twee woorden die microservices mooi omschrijven. Een microservice omvat een stukje business logica. De algemene logica van authenticatie en authorisatie mag niet in een microservices gegoten worden. 
\end{itemize}
In het algemeen zijn authenticatie en authorisatie een complex onderdeel van microservices.
Er zijn vier oplossingen volgens \textcite{Ayoub2018}
\begin{itemize}
	\item Distributed session manangement,
	\item client token,
	\item single sing-on, 
	\item client token with API gateway.
\end{itemize}
Distributed Session management is de eerste oplossing. Het managen van een sessie over microservices. Dit kan op verschillende manieren. Aan de hand van Sticky sessions. Dit houdt in dat alle requests van één gebruiker naar dezelfde server worden gestuurd. Dan kan men ervan uitgaan dat de gebruikte data van die specifieke gebruiker is. Of men kan dit toepassen via session replication. Dit houdt in dat alle instanties de sessie data synchronizeren. Deze manier van toepassen heeft als nadeel dat er veel overhead aanwezig zal zijn op het netwerk. Een andere methode is centralized session storage. Deze omvat dat bij het aanspreken van een microservice, deze de gebruikersdata gaat ophalen van op een gedeelde plaats. 
Een andere manier om authenticatie en authorizatie toe te passen is via een client token. Een token wordt gebruikt om aan te tonen dat je echt de gebruiker bent. Een token wordt bijna altijd onleesbaar gemaakt. Het klinkt bijna hetzelfde als een sessie. Het verschil ligt hem in het feit dat een sessie op de server centraal wordt bijgehouden. Een token wordt bijgehouden door de user zelf.
Naast de Distributed session management en client token is er nog single sign-on. Na een enkele aanmelding, kan de gebruiker alle microservices gebruiken binnen de applicatie. 
Een andere manier is een client token with API gateway. Deze manier is gebaseerd op de client token. Maar nu is er een API gateway toegevoegd aan het begin van een externe request. Dit zorgt ervoor dat het framework niet zichtbaar is aan de buiten wereld. 

De meest voorkomende methodes in API authenticatie terug te vinden in tabel 2.2, \textcite{Sandoval2018}.
\begin{table}[]
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|p{2cm}|p{5cm}|p{5cm}|p{5cm}|}
			\hline 
			 
				& HTTP Basic Authentication
				& API keys
				& OAuth \\ \hline
			Definitie  
				& 'A HTTP user agent simply provides a username and password to prove their authentication'. 
				& 'An unique generated value is assigned to each first time user, signifying that the user is known. When the user attempts to re-enter the system, their unique key is used to prove that they’re the same user as before.'.
				& 'The user logs into a system. That system will then request authentication, usually in the form of a token. The user will then forward this request to an authentication server, which will either reject or allow this authentication. From here, the token is provided to the user, and then to the requester. Such a token can then be checked at any time independently of the user by the requester for validation, and can be used over time with strictly limited scope and age of validity'.\\ \hline
			Voordelen
				& Er is geen nood aan tokens, session ID's, login pagina's en een handshake bevestigen is niet nodig.
				& Dit is een manier van authenticatie die snel gebeurt. Het is een niet zo complex proces om de sleutels te genereren. 
				& Het is de beste manier van authenticatie en authorisatie uit deze tabel. \\ \hline
			Nadelen
				& Is er geen SSL (Secure Sockets Layer) aanwezig dan is het eenvoudig om de gegevens op te halen en ligt alles open en bloot op het internet. Bij het gebruik van SSL is er een nadeel. De tijd dat moet gewacht worden op een antwoord wordt vertraagd.
				& De API key is niet geschikt voor authorisatie. Bij het fout gebruik van API keys kan dit een grote impact hebben op de bescherming van de applicatie.
				& Als er enkel gebruik moet gemaakt worden van één van de twee, authenticatie of authorisatie, dan is OAuth overbodig. Want OAuth heeft veel meer te bieden. 
				\\ \hline
		\end{tabular}%
	}
	\caption{De verschillende methoden in API authenticatie, \textcite{Sandoval2018}}
\end{table}

Het proces van een API gateway dat authenticatie en authorisatie op zich neemt, \textcite{Siraj2017}.
Door de API Gateway to combineren met JSON  web Tokens is er meer mogelijkheid om te schalen. 
\begin{enumerate}
	\item De gebruiker meldt zich aan.
	\item De API gateway stuurt de request door naar de server die instaat voor de auhtenticatie.
	\item Is de authenticatie goedgekeurd, wordt er een JWT token terug gestuurd naar de gebruiker. Meer uitleg over de JWT na dit proces.
	\item Bij volgende request wordt de token automatisch meegestuurd met de request.
	\item Een andere server kijkt bij elke request naar de token, om na te gaan of de gebruiker de juiste authorisatie heeft. 
\end{enumerate}
De token vervalt na een bepaalde tijd. Er kan gekozen worden om deze automatisch te laten verlengen. Hier wordt niet verder op ingegaan. 

De definitie van JSON  web Token, \textcite{Stecky-Efantis2016}: 'A JSON  web Token (JWT) is a JSON object that is defined in RFC 7519 as a safe way to represent a set of information between two parties. The token is composed of a header, a payload, and a signature.'. Het diagram te zien in figuur 2.6, is een schematische voorstelling van hoe een JWT token wordt gegeven aan een gebruiker.
\begin{figure}[h]
	\includegraphics[width=10cm]{jwt.png}
	\centering
	\caption{Een schematische voorstelling van het geven van een JSON  web Token. \textcite{Stecky-Efantis2016}}
\end{figure}
Het proces gaat als volgt:
\begin{enumerate}
	\item Aanmelden op een platform. Bijvoorbeeld aanmelden op Facebook, Twitter, Instagram of Google.
	\item De authenticatie server stuurt een JWT terug.
	\item Bij het maken van requests wordt de token meegestuurd.
	\item De microservice kijkt dan of de gebruiker het recht heeft om deze microserivce/functie te gebruiken.
\end{enumerate}


\subsubsection{Verband met Agile en DevOps}
Microservices komen uit dezelfde ideologie als Agile en DevOps. DevOps is een contaminatie  van development en operations. Bij deze methode ligt de nadruk op de samenwerking en communicatie tussen verschillende partijen. Hier zijn de partijen de software engineers en andere IT specialisten. Deze ideologie omvat het volgende: het afbreken van kleine, traag evoluerende architectuur of monolithic en deze in microservices steken.

DevOps heeft volgende definitie: 'DevOps is a methodology that enables developers and IT Ops to work closer together so they can deliver better quality software faster', \textcite{Morgan2019}. Met DevOps probeert men de productie zo goed mogelijk na te bootsen. Net zoals bij Agile, zorgt DevOps ervoor dat de software in kleinere delen wordt opgesplitst om weer op kortere periodes kleinere deeltjes software op te leveren. Dit is iets waar ' microservices in terug te vinden is. Verschillende DevOp teams kunnen dus tegelijkertijd aan microservices  werken.

Enkele voordelen van de combinatie microservices en DevOps:
\begin{itemize}
	\item Meer opleveringen van software op kortere periodes.
	\item Betere kwaliteit van de code.
	\item Software kan hergebruikt worden.
	\item Een hoger level van automatisatie.
\end{itemize}

Microservices en DevOps vullen elkaar aan op volgende vlakken, \textcite{Mulesoft2019}:
\begin{itemize}
	\item Deployability: Microservices bemoedigen het gebruik van Agile omdat het eenvoudiger is om periodiek op te leveren. 
	\item Reliability: Een fout binnen een microservice, heeft enkel effect op die microservice. 
	\item Availability: Het opleveren van nieuwe  deeltjes, neemt niet veel tijd in beslag. De gehele applicatie zal niet lang offline zijn.
\end{itemize}




\subsubsection{Het monitoren van microservices}
Logs zijn records binnen een databank naar weggeschreven wordt terwijl de applicatie draait. Metrics zijn numerieke waarden die kunnen geanalyseerd worden. Metrics zijn terug te vinden op volgende niveau's van een applicatie, \textcite{Wasson2018}:
\begin{itemize}
	\item Node-level: Dit houdt in de gegevens van de CPU, het geheugen, netwerk en de harde schijf. 
	\item Container: Draait de service binnen een container dan moeten er metrics bijgehouden worden van die container. 
	\item Applicatie: Hier kunnen metrics bijgehouden worden om het gedrag van de service te begrijpen. Gegevens die kunnen bijgehouden worden zijn het aantal HTTP requests, de vertraging en de lengte van een bericht.
	\item Dependent service: Bij interactie met een externe service, hoelang deze duurt voordat de externe service reageert. 
\end{itemize}


Het monitoren of loggen van microservices houdt in dat er wordt bijgehouden hoe een microservice zich gedraagt. Er wordt bijgehouden hoe snel de data wordt opgehaald uit de databank. Bij het vinden van problemen is monitoren een belangrijk onderdeel. Dankzij monitoring kan een bug sneller gevonden worden. Er kan worden nagegaan hoelang het duurde om een bepaalde request te maken. Van die gegevens kunnen er dan conclusies getrokken worden, \textcite{Ananthasubramanian2018}.

Loggen is belangrijk omdat bij meerdere services het moeilijk kan zijn om het traject binnen de services te volgen, \textcite{Saldanha2016}.

De verschillende tools om te debuggen, \textcite{Swersky2019}:
\begin{itemize}
	\item Logging frameworks: Het is een open-source oplossing. Er zijn verschillende opties, bij het kiezen wordt er best rekening gehouden met volgende puntjes:
		\begin{itemize}
			\item De netheid van de code. Is de logging code gemakkelijk te lezen?
			\item Wordt de performance beeïnvloedt?
			\item Is het framework voor logging al gekend onder het team?
		\end{itemize}
	\item Logging databases: Log data wordt gebruikt voor het capturen van events. Logs worden nooit aangepast. Logs worden ' gesorteerd op datum en tijd. 
\end{itemize}



Bij microservices wordt elke microservice gelogd. Bij een fout moet er gekeken worden naar alle betrokken microservices. Er moet gekeken worden naar alle logs van de services. Om logging toe te passen wordt er aangeraden om libraries te gebruiken. Enkele best practices, \textcite{Melendez2018}, \textcite{Eyee2018}, \textcite{Timms2018}:
\begin{itemize}
	\item Probeer te vermijden dat logs in bestanden worden opgeslaan. Logs zijn streams van een flow. Het geeft  weer wat er juist gebeurt is in een flow.
	\item Microservices moeten niet  weten waar de logs naartoe gaan. Zo kan de bestemming van het  wegschrijven van de logs veranderd worden zonder dat elke microservice ervoor moet aangepast worden.
	\item De logging zou moeten  werken voor alle verschillende codeertalen. Er zou niets moeten worden aangepast bij de configuratie files van het logging systeem.
	\item Geef elke request een uniek ID. Zo kan de request snel teruggevonden worden bij falen. Of bij het zien van een fout kan er snel achterhaald worden  welke request er in fout is gegaan. 
	\item Laat het antwoord ' een uniek ID meesturen. Als de gebruiker dan een fout krijgt, kan er achterhaald worden vanwaar de teruggestuurde fout komt. De administrators kunnen dan de details van de fout bekijken.
	\item Een oplossing is om alle logs  weg te schrijven naar een centrale databank. Zo kan het hele pad van de fout snel en eenvoudig teruggevonden worden. Het duurt langer om verschillende fouten aan elkaar te linken als de logs in de datastore van de microservice worden opgeslaan. Bij het opslaan op één plaats, worden fouten sneller aan elkaar gelinkt. Het  wegschrijven naar een plaats is tegen het principe van microservices. Binnen die enkele database met alle logs kan er gezocht worden op fout, microservice, tijdstip, .... ' het volgen van een gebruiker zijn traject binnen de applicatie is eenvoudiger. Bij een fout kan er gekeken worden naar de acties die er op voorhand zijn gemaakt. 
	\item Zorg voor structuur in de log data. Een algemene format zoals JSON of XML om een structuur te creëeren in de logs. 
	\item Geef iedere request een context.  Weten wat de oorzaak is van de fout, is belangrijk om ervoor te zorgen dat de fout zich niet zal herhalen. Volgende velden zouden zeker in de log terug te moeten vinden zijn:
		\begin{itemize}
			\item Dag en tijd.
			\item Stack errors.
			\item De naam van de service, om de logs te linken aan microservices.
			\item In  welke functie de fout is ontstaan.
			\item De naam van de externe service waar er interactie mee is geweest.
			\item Het IP adres van de server en van de gebruiker zijn requests. 
			\item De browser waaruit de gebruiker de request stuurde.
			\item De HTTP code om later alerts te creëren. 
		\end{itemize}
	\item Overweeg om de logs naar een lokale databank  weg te schrijven. Elke oplossing heeft zijn voordelen en nadelen. Het  wegschrijven over HTTP naar de cloud kan zorgen voor meer verkeer op het netwerk. De bandbreedte kan bij belangrijke microservices vermindert worden. 
	\item Kijk na wat er gelogd wordt, is het niet nodig om iets te loggen, laat het achterwege. Maar bij de start van loggen, wordt er best te veel gelogd. Zodat er eerst teveel info is en dan kan er gesneden worden in de inhoud van het loggen.
\end{itemize}



\subsection{Algemene aanpak om microservices te implementeren}
Voordat er wordt begonnen aan het overschakelen naar microservices, moet er research gedaan worden, \textcite{Koukia2018}. De logische eerste stap is het lezen van artikels en hoe andere bedrijven zijn overgeschakeld naar microservices. Wat hun problemen en moeilijkheden waren. Door artikels en ervaringen van anderen te lezen, kan je zelf mogelijke problemen voorkomen. Na de verdieping in microservices, moet er een plan opgemaakt worden. Het opstellen van dit plan gebeurt doorgaans in samenwerking met meerdere personen. Op die manier is er een bredere waaier aan opinies en om ervoor te zorgen dat iedereen op dezelfde lijn zit.


\textcite{Benetis2016} schreef een zesstappen plan om microservices te implementeren. Over de grote lijn wordt hierop gebaseerd. Stap per stap gaat er dieper op de overschakeling worden ingegaan.
Een paar woorden die meer verklaring nodig hebben voordat  we  verder gaan. Een gateway is een netwerkpunt dat dient als toegang tot een ander netwerk.
Implementatie is een procesmatige invoering van een verandering of vernieuwing. 

Kort uitgelegd, is dit het zesstappen plan. Als eerste komt aan bod 'serve a business purpose'. Hierna komt 'protect your stuff'. Eens dat gebeurt is, zegt het artikel 'see no evil, hear no evil'. Dan komt 'find your stuff' aan bod. Hierna wordt de volgende stap 'create a gateway' aangehaald. Als laatste komt 'construct events' aan de beurt.

De eerste stap is 'Serve a business purpose'. De titel zegt al veel van wat er verwacht wordt. Een microservices is gebaseerd op een business requirement. En niet het doel dat het IT-team voor ogen heeft. Een voorbeeld van een business requirement is het ophalen van data om die dan te analyseren om daar later dan conclusies uit te trekken. Dit kan in een microservices gegoten worden. Eens het doel voor ogen is bij een microservices, moet er ' gekeken worden naar wat de microservices moet kunnen. Komen enkel microservices aanbod dan is automated deployement niet van groot belang. Maar eens men gaat schalen en meerdere microservices in één systeem onder gebracht. Er wrodt verwacht dat volgende puntjes toch self-sufficient zijn:
\begin{itemize}
	\item Geautomatiseerde implementatie
	\item Blootstelling aan andere systemen, toegankelijk eindpunt
	\item Opslag van data
	\item Schaalbaarheid en belasting
\end{itemize}
Zoals te zien is op figuur 2.7, is een microservices één klein deeltje in een groot geheel. Later in dit stappenplan zal de figuur ' uitgebreidt worden en zal het geheel duidelijk worden. 
\begin{figure}[h]
	\includegraphics[width=10cm]{1.png}
	\caption{Een microservice dat voldoet aan een business requirement. \textcite{Benetis2016}}
	\centering
\end{figure}

Na 'Serve a business purpose' komt 'Protect your stuff'. Dit gaat over de bescherming van een microservice. Bescherming moet op elk moment toegepast worden. Eveneens er sprake is van één à t wee microservices, of honderden, bescherming is belangrijk. Het is belangrijk om over al de microservices een uniforme manier te vinden om ze te beschermen. De bescherming kan een requirement op zich zijn, dit kan in een microservices worden gestoken. Bescherming is een vage term daarom een korte uitleg van hoe een bescherming er zou kunnen uitzien. De meest bekende manier is natuurlijk authorisatie en authenticatie.  De controle of jij het  wel echt bent. Een manier op de microservices te beschermen is gecentraliseerde session opslag. Kort uitgelegd betekend gecnetraliseerde session opslag dat de data van de user centraal opgeslagen staat. Zodat alle microservices de zelfde session data lezen en gebruiken. 
\begin{figure}[h]
	\includegraphics[width=10cm]{2.png}
	\caption{Een microservice waar bescherming aan is toegevoegd. \textcite{Benetis2016}}
	\centering
\end{figure}
In figuur 2.8 is de authenticatie in een microservices gestoken. 

Na de eerste twee stappen komt 'See no evil, hear no evil'. Eens de microservice is opgezet en gedeployed, moet er gemonitord worden. Daarmee wordt bedoeld dat hoe de microserivces zich gedraagd goed moet bijgehouden worden. Alles zou goed moeten gelogd worden, zodat bij een probleem het geen moeite is om te vinden waar het probleem zich voordeed. Hier is het aangeraden om doorheen het hele systeem een uniforme manier van loggen aan te houden. Men kan hiervan een microservice maken. Dit wordt ' afgebeeld in figuur 2.10.
\begin{figure}[h]
	\includegraphics[width=10cm]{3.png}
	\caption{Een microservice waar er monitoring is aan toegevoegd om chaos te voorkomen. \textcite{Benetis2016}}
	\centering
\end{figure}

Als vierde stap komt er 'Find your stuff'. In deze stap wordt er gezocht naar een manier om de microservices met elkaar te communiceren. Hiermee wordt bedoelt hoe dat microservices A gegevens vragen aan microservices B. Die dit op zijn beurt vraagt aan  een andere microservice. Een veel gebruikte techniek hiervoor is 'service registry'. Een service registry is een databank waar alle services met hun instanties en locatie woren opgeslaan. Daar worden dan ' connecties in opgeslaan. Er wordt aangeraden om dat in een microservices te gieten. Zodat hiervan het gedrag kan gemonitord worden. In figuur 2.10 zie je hoe de service registry kan toegevoegd worden. In de figuur is die terug te vinden onder de naam 'service discorvery'.
\begin{figure}[h]
	\includegraphics[width=10cm]{4.png}
	\caption{Een microservice dat authenticatie als bescherming toepast. \textcite{Benetis2016}}
	\centering
\end{figure}

Nu is er een service, bestaande uit microservices, dat beschermd is en kan doen wat het zou moeten doen. Maar niet de  volledige service moet open en bloot gelegd worden. En daar zorgt stap 5, 'Create a gateway', voor. Een API gateway kan een scherm zijn waar je gegevens op invult en mogelijke acties op doet en die spreken dan de correcte microservices aan. De taak van een gateway is voornamelijk zorgen dat request/aanvragen naar de juiste microservice worden doorgestuurd. Andere taken van een API gateway kunnen volgende zijn
\begin{itemize}
	\item Beveiliging: een API gateway kan de binnenkomende aanvragen valideren. 
	\item Prestatiegegevens kunnen geregistreerd worden.
	\item Omzetten van aanvragen in enkele of meerdere microservices.
	\item Abstractie van de clientinterface. Wanneer er van microservice verandert wordt, moet er niet van interface/scherm verandert worden. 
\end{itemize}

In figuur 2.11 is te zien hoe zo een API gateway kan worden toegepast. Zo is te zien dat de authenticatie microservice er niet inzit. Die wordt apart gehouden. De request naar de authenticatie mogen niet langs de API gateway gaan. Omdat ze dan zo meteen 'binnen' zitten. Pas na authenticatie mag men een request sturen naar de API gateway.
\begin{figure}[h]
	\includegraphics[width=10cm]{5.png}
	\caption{Een microservice dat een gateway gebruikt. \textcite{Benetis2016}}
	\centering
\end{figure}

Nu is er al een deftige architectuur aanwezig. Stap 6, 'construct events', zal het plaatje dan ' compleet maken. De meeste microservices vragen aan asynchrone oplossing. Een niet-gelijktijdige verwerking van aanvragen. Een manier om asynchroon te  werken, is  werken met een queue of wachtrij. Een bekende manier om asynchroniteit toe te passen is publish/subscribe pattroon. Dit wil zeggen dat microservice A zijn berichten of data op een wachtrij gaat zetten. De microservices die data of berichten van microservice A moeten ontvangen, gaan zich abonneren op die wachtrij. Dus vanaf het moment dat microservice A iets op die wachtrij plaatst, krijgen de geabonneerden een melding en kunnen ze het bericht ophalen. Enkele voordelen van dit als asynchrone oplossing te gebruiken:
\begin{itemize}
	\item Taken kunnen ingepland worden. Dit kan door deze gewoon op de wachtrij te plaatsen met een timestamp van wanneer deze moet gebeuren of door een wachtrij te maken voor geplande events.
	\item Abonneren op bepaalde events.
	\item Het asynchrone systeem laten bloot leggen zodat externe klanten verschillende notificaties kunnen handelen.
\end{itemize}
In figuur 2.12 wordt de volledige architectuur  weergegeven. Daar wordt er ' mooi afgebeeld hoe men events pland. Als event A voor event B moet gebeuren dan zetten ze die zo op de wachtrij event A voor event B want een wachtrij  werkt volgens het FIFO (first in first out) principe.
\begin{figure}[h]
	\includegraphics[width=10cm]{6.png}
	\caption{Een microservice met asynchronisatie. \textcite{Benetis2016}}
	\centering
\end{figure}

\textcite{Benetis2016a} beschrijft dat over volgende puntjes goed moet worden nagedacht voordat men de overschakeling maakt naar microservices:
\begin{itemize}
	\item Heeft de organisatie de microservice architectuur  wel nodig?
	\item Zijn de juiste competenties aanwezig? Microservices zijn in het algemeen complexer dan een monolithic. Zeker omdat dit iets nieuws is. 
	\item  Staat iedereen achter deze verandering?
\end{itemize}
Bij de beslissing om over te schakelen, moet er beslist worden hoeveel de infrastructurele veranderingen van de scope inpalmen. Het verloop gaat als volgt. Eerst het uit elkaar trekken van het bestaande systeem, om het dan in microservices te steken, is een goed begin. Zo moet er constant nagedacht worden over de algemene infrastructuur. Een groot valluik in het begin van het proces is een proof of concept maken. Dit eindigt meestal in een infrastructuur dat niet overeenkomt met de waarden van microservices. Het probleem ligt dan meestal bij een onduidelijke scope. De business requirements zijn meestal  wel duidelijk, dit geldt dan meestal niet voor niet-functionele requirements. Daarnaast moeten ' nog volgende stappen gerealiseerd worden:
\begin{itemize}
	\item Bescherming.
	\item Deployment automatisatie.
	\item Loggen en monitoren van microservices hun gedrag.
\end{itemize}
Velen komen niet tot deze stap, door de onderschatting van de overschakeling naar microservices.


\subsection{De voordelen en nadelen van microserivces}
Er wordt veel goed geschreven over microservices. Het gebruik van microservices zou ervoor zorgen dat de architectuur flexibeler wordt. Met flexibeler wordt bedoelt dat de architectuur zich kan 'aanpassen' of kan inspelen op verschillende situaties. Microservices kunnen meerdere keren terugkomen in een architectuur. Dit wordt duidelijker in de methodologie. Dankzij microservices is het hermodeleren, implementeren van nieuwe  technologieën, ... eenvoudiger.
Kleinere deeltjes zijn gemakkelijker te documenteren. De snelheid van microservices zijn een groot pluspunt. Hiermee wordt er geprobeert om aan te halen dat microservices sneller reageren omdat zo kleine, onafhankelijke services zijn. Ze moeten geen 'onnodige' stappen maken om de  wens van de klant te vervullen. 
\textcite{Watts2018} geeft enkele voordelen van een microservice. Een developer is onafhankelijk. Ze hebben vrijheid. Het scalen van een microservice is veel eenvoudiger. Dit komt door dat microservices minder resources nodig hebben dan een volledige monolithic. Resources zijn hulpbronnen. Zoals al vaak aangehaald in deze bachelorproef, zijn microservices onafhankelijk en zouden ze daarom geen hulpbronnen nodig mogen hebben. Binnen een monolithic zijn deeltjes afhankelijk van elkaar en hebben elkaar dus nodig om goed te kunnen functioneren. De deeltjes binnen de monolithic hebben elkaar dus nodig en mogelijk als hulpbron. Een ander voordeel is bij het falen van een microservices, de andere microservices er geen last van zullen hebben. Dit komt door hun onafhankelijkheid. 
\textcite{Benetis2016} geeft aan dat volgende puntjes voordelen zijn van microservices:
\begin{itemize}
	\item Sneller en gemakkelijker developen
	\item Het refactoren van deeltjes is eenvoudiger door de onafhankelijkheid van de services
	\item De schaalbaarheid is eenvoudiger dan bij een monolithic. Men kan microservices gewoon 'klonen' of kopieëren
	\item Het deployen van een onderdeel gaat sneller omdat het team gespecialiseerd is in die bepaalde service
	\item Als er iets faalt dan is de impact veel kleiner dan bij een monolithic. Dit komt ' door de onafhankelijkheid van de services
\end{itemize}
Maar om ervoor te zorgen dat dit allemaal vlot verloopt moeten er aanpassingen binnen in het bedrijf/ de organisatie gebeuren. 
\begin{itemize}
	\item Een project zal ingedeeld moeten worden in kleine requirements. De scope zal gedetailleerder moeten zijn.
	\item Een team zal kleiner zijn. Zodat er meer op de Agile methode kan gewerkt worden.
	\item Er zal een sterke band komen met DevOps. Dit komt omdat veel services volledige automatische deployment vragen.
	\item De communicatie tussen de services zal beter moeten worden uitgedacht.
	\item Documenteren is belangrijk. Dit is niet enkel het geval voor microservices maar ook voor elk project.
\end{itemize}

Enkele nadelen en moeilijkheden, \textcite{Koukia2018}:
\begin{itemize}
	\item Distributed systems zijn ingewikkeld. Microservices vragen meer  werk. Dit komt omdat het een nieuwere technologie is en het concept is niet altijd meteen duidelijk. 
	\item Complexiteit is overal. Een monolithic bevat complexiteit, maar  wel een bekende complexiteit. Als er al een tijdje gewerkt wordt met monolithic, dan is die complexiteit een bekende eigenschap van de architectuur. Omdat microservices iets nieuws is, komt er complexiteit die minder bekend is onder de developers.
	\item Debuggen en fouten vinden is moeilijker. Bij een monolithic is het eenvoudig, bij aanpassingen wordt de volledige architectuur gerund. De gehele architectuur bij een microservices moet getest worden. Hier werd in het vorige deel meer uitleg over gegeven.
	\item Bij aanpassingen binnen een monolithic moest er maar één request gedaan worden om code samen te voegen. Bij microservices is dit verschillend. Er moet bijvoorbeeld in vier microservices iets aangepast worden voor een nieuwe  feature. Dan moeten er vier requests verstuurd worden om die code te mergen. Want de services binnen de microservice architectuur zijn onafhankelijk van elkaar. 
\end{itemize}

\section{Microservices integration patterns}
Hierboven werd uitgelegd wat microservices zijn. Het zijn kleine, onafhankelijke services (synoniem vinden). Maar die moeten met elkaar kunnen communiceren, taken uitvoeren, data updaten en raadplegen. Er zijn manieren om microservices gestructureerd te integreren in de applicatie. Dit kan aan de hand van 
Die verschillende manieren zijn onderstaande patterns:
\begin{itemize}
	\item Anti-patterns
	\item Communicatie tussen de microservices
	\item Data integration
	\item Extract, transform en load (ETL)
	\item REST	
\end{itemize}

In het derde hoofdstuk zal één van de bovenstaande patterns theoretisch toegepast worden op het order-to-cash proces. Het order-to-cash proces zal verder uitgelegd worden in deel 2.3.
\subsection{Anti-patterns}
Anti-patterns ontstaan bij een ongeplande overschakeling naar microservices. Wanneer microservices gebruikt worden, zonder grondig onderzoek, kan dat tot chaos leiden. Anti-patterns komen vaker voor dan een gestructureerde microservice architectuur. Er moet grondig onderzoek gedaan worden naar de verschillende 'microservice integration patterns'. Op welke manier kan de applicatie, gestructureerd, naar een microservice architectuur gewerkt worden.
De meeste mensen hebben niet door dat ze een anti-pattern aan het maken zijn. Door ongestructureerd de microservices te gebruiken, kan er, onbewust, een anti-pattern ontstaan. 

Er zullen vier anti-patterns besproken worden. Dit kan helpen bij het achterhalen van een anti-pattern. Volgende anti-patterns zullen besproken worden, \textcite{Monson2019}:
\begin{itemize}
	\item Break the piggy bank
	\item Everything micro
	\item We are Agile: The Frankenstein
\end{itemize}
\subsubsection{Break the piggy bank}
Bij deze manier van toepassing van microservices kan de applicatie voorgesteld worden als een spaarvarken. Om van een monlithic applicatie naar een microservice applicatie te gaan, moet het spaarvarken (de monolithic applicatie) aan stukken geslaan worden. De applicaties architectuur wordt volledig uit elkaar gehaald en in kleine delen opgedeeld. De kleine delen worden omgezet naar microservices. In het begin van de verandering naar microservices, lijkt het dat de complexiteit verminderd. Maar eens verder in het proces zal het duidelijk worden dat het enkel schijn was, de complexiteit wordt enkel verhoogd. Dit komt door de ongestructureerde manier waarop men te werk is gegaan.
De applicatie is opgedeeld in onderdelen en die onderdelen zijn omgezet in microservices. Bij het samenvoegen van de microservices tot een architectuur, is het mogelijk dat de applicatie een mini-monolithic wordt. Dit komt voor wanneer de services niet opgedeeld worden en willekeurig worden samengevoegd.
Dit anti-pattern is het populairst wanneer een monolithic applictie niet meer houdbaar is. 
\begin{figure}[h!]
	\includegraphics[width=10cm]{breakthepiggybank.png}
	\centering
	\caption{Break the piggy bank, van monolithic naar microservices via anti-pattern \textcite{Monson2019}}
\end{figure}

\subsubsection{Everyting micro}
Alles in de applicatie wordt omgezet naar microservices, behalve de databank. Bij deze anit-pattern blijft de databank dezelfde als bij de monolithic applicatie. De verschillende microservices moeten de data uit een gemeenschappelijke databank opvragen. De databank is de 'bottleneck' in de applicatie. De term 'bottleneck' wordt gebruikt wanneer een plaats is binnen de applicatie waar alle delen vertraagt worden. Een 'bottleneck' is een soort van trechter. Alle aanvragen komen binnen maar er kunnen maar enkele verwerkt worden. Daar wordt vertraging opgelopen. 
Om de data van de databank op te halen moet er aan 'access control' gedaan worden. Niet alle microservices kunnen tegelijkertijd hun data opvragen en ontvangen. De databank moet op een gecontroleerde manier gebruikt worden. Wie de databank wanneer mag 'gebruiken' moet goed uitgedacht zijn. Anders is er kans op 'deadlock'. Deadlock komt voor wanneer twee of meerdere services data van de databank willen halen. Wanneer er geen controle gebeurt over de toegang kan het zijn dat een services de databank voor zichzelf houdt.
De onderdelen van de applicatie kunnen microservices zijn, maar als de databank nog steeds monolithic is, wordt de 'bottleneck' verplaatst.
De datastructuur blijft monolithic.
In het begin lijkt dit niet zo een groot probleem. Maar de monolithic databank heeft een negatieve invloed op de applicatie. Naast de negatieve invloed is er een uitdaging: de verandering van de databank schema's bijhouden. Wanneer er een aanpassing gemaakt wordt, moet dat bijgehouden worden. Omdat er maar één databank gebruikt wordt, moet elke verandering van elke microservices genoteerd worden. Naast die uitdaging, moet bij een verandering in de productie databank, de volledige applicatie opnieuw gedeployed worden. Een productie databank is de databank die live gebruikt wordt. Het is de databank waarmee je communiceert als je op Zalando iets besteld. 
\begin{figure}[h!]
	\includegraphics[width=10cm]{everythingmicro.png}
	\centering
	\caption{Everyhting micro, anti-pattern met een monolithic databank. \textcite{Monson2019}}
\end{figure}

\subsubsection{We are Agile: The Frankenstein}
Dit anti-pattern ontstaat vaker door de overschakeling van waterval analyse naar de Agile methodologie. Door die overschakeling kan er gedacht worden dat er niks meer gedaan moet worden op vlak van voorbereiding. Dat alles duidelijk zal worden eens het probleem zich echt voordoet. De meeste teams gaan van de waterval methode naar een combinatie van Agile en waterval. 
Door een ongestructureerde planning, worden er losse delen geprogrammeerd. Die losse delen moeten samen werken. Ze worden aan elkaar 'genaaid' om samen te werken. Net zoals Frankenstein aan elkaar is genaaid met verschillende onderdelen. Al de samengevoegde onderdelen moeten de data delen. Moet er een nieuw deel functionaliteit toegevoegd worden, wordt de architectuur complexer en moeilijker om te deployen. 
Omdat de architectuur een samenhang is van onderdelen, kan de applicatie op lange termijn dingen doen dat niet zou mogen. Er zouden transacties kunnen gebeuren die niet mogen gebeuren binnen de applicatie. De mogelijkheid bestaat dat de applicatie gewoon uit elkaar valt door de slechte architectuur en de chaos die er is. 
\begin{figure}[h!]
	\includegraphics[width=10cm]{frankenstein.png}
	\centering
	\caption{The Frankenstein, anti-pattern waarbij de microservices bij elkaar zijn gevoegd zonder samenhang. \textcite{Monson2019}}
\end{figure}



\subsection{Communicatie tussen de microservices}
Er zijn verschillende manieren om microservices te laten communiceren met elkaar. De verschillende microservices moeten met elkaar kunnen communiceren om data uit te wisselen. De microservices kunnen bijvoorbeeld elke microservice kennen die het nodig heeft. Maar dit maakt de gehele architectuur enkel maar complexer. Zoals in afbeelding X te zien is, wordt de architectuur chaotisch bij deze manier van communiceren.
\begin{figure}[h!]
	\includegraphics[width=10cm]{chaos.PNG}
	\centering
	\caption{Een architectuur waarbij de microservices elkaar direct kennen om informatie met elkaar te delen.}
\end{figure}

Dit zorgt ervoor dat de microservices niet meer onafhankelijk zijn van elkaar. Ze worden weer afhankelijk van elkaar en vormen zo een mini-monolithic. Een soort anti-pattern zal ontstaan. Om ervoor te zorgen dat microservices onafhankelijk blijven, kan er 'messaging' toegepast worden, \textcite{Solance2018}. Messaging is een manier van communiceren, om business entiteiten up te daten, dat gebeurt via een 'message broker'. Een 'message broker' is de logica die de berichten van een microservice naar een andere stuurt zonder dat ze elkaar moeten kennen. Het meest gekende patroon hiervoor is publish-subscribe pattern. Deze wordt weergegeven in afbeelding X.
\begin{figure}[h!]
	\includegraphics[width=10cm]{messaging.PNG}
	\centering
	\caption{Een architectuur waarbij een message broker als communicatiemiddel wordt gebruikt.}
\end{figure}
In de 'message broker' heeft elke microservices zijn queue. De queue is een wachtrij waar berichten worden opgeslaan. De berichten worden verwijderd van de queue eens ze gelezen en opgehaald worden. Het bericht moet eerst gelezen worden voordat het verwijderd kan worden van de queue. 
Een microservice stuurt een bericht naar de 'message broker' en moet zich verder niks van het bericht aantrekken. De 'message broker' zorgt ervoor dat het bericht bij de juiste microservice(s) wordt afgeleverd. De uiteinden kennen elkaar niet. Ze kunnen volledig onafhankelijk van elkaar functioneren. Dit is een doel van microservices. En om dat doel te bereiken, moet de manier van communicatie goed gekozen worden.

\subsection{Data integration}
Een opsomming van enkele definites omtrend 'Data integration':
	\begin{itemize}
		\item 'Two or more services read and write data out of one central data store', \textcite{Aradhye2018}.
		\item 'Microservices embrace independent, autonomous, specialized service components,
		each with the freedom to use its own data store', \textcite{Kumar2018}
	\end{itemize}

Een opvallende eigenschap aan een monolithic architectuur is de centrale databank. Bij de overgang wordt de databank regelmatig uit het beeld gelaten, omdat er gedacht wordt dat er niks aan de databank moet veranderen. De data blijft hetzelfde, dat is correct. Maar de structuur waarmee er met de data wordt gewerkt, verandert in zijn geheel. De oude databank, die bij de monolithic gebruikt werd, is niet de optimale oplossing. 
Als de monolithic databank nog gebruikt wordt bij een microservice architectuur, brengt dat veel problemen en obstakels met zich mee. Volgende zijn enkele voorbeelden:
\begin{itemize}
	\item De microservices zijn afhankelijk van de databank en zijn daardoor afhankelijk van elkaar. Als ze meerdere microservices de databank nodig hebben, moeten ze wachten tot de ander gedaan heeft.
	\item Microservices onafhankelijk deployen, is onmogelijk. Een aanpassing heeft invloed op de databank en elke microservice kent de databank. 
	\item Een microservice schalen wordt een moeilijke opgave omdat die vasthangt aan de centrale databank. 
	\item Omdat alle data in één databank wordt bijgehouden, worden de tabellen gigantisch groot en op termijn onhoudbaar en slordig. 
\end{itemize}

Elke microservices heeft elk zijn eigen databank met data betreffende hun functionaliteit. Hieronder kunnen enkele voorbeelden teruggevonden worden over de voordelen van een microservice met een eigen databank:
\begin{itemize}
	\item De databank bevat enkel de relevante data.
	\item Elke microservices kan apart gedeployed worden. Niemand anders is verbonden met zijn databank.
	\item Een microservices kan niet rechtstreeks aan de databank van een andere microservices. Hoe een microservices onrechtstreeks de databank van een ander kan, zal later uitgelegd worden.
\end{itemize}

Sommige microservices hebben data van andere microservices nodig. Omdat hun databank de geweste gegevens niet kan leveren. De data wordt dan gevraagd aan de databank via een de microservice zelf.
\begin{figure}[h!]
	\includegraphics[width=10cm]{db.PNG}
	\centering
	\caption{Hoe een microservice de databank van een andere microservice aanspreekt.}
\end{figure}
 
 De manier waarop een microservice een andere microservice zijn databank aanspreekt, gebeurt zoals beschreven in het vorige deel over 'communicatie tussen de microservices'.
 
 Eens de volledige communicatie is uitgedacht, moet er een databank gekozen worden, passend bij de micoservices. Het kan zijn dat voor de ene microservices een SQL-databank beter past en voor de ander een NOSQL-databank. SQL en NOSQL zijn soorten databanken. De manier waarop de data wordt opgeslaan, opgevraagd en teruggestuurd is anders. 
 
\subsection{Extract, transform en load (ETL)}
Volgende opsomming bevat verschillende definities omtrent ETL:
\begin{itemize}
	\item 'The type of data integration that refers to the three steps used to blend data from multiple sources', \textcite{Loshin2019}.
	\item 'Data from multiple systems is combined to a single database, data store, or warehouse for legacy storage or analytics', \textcite{Alley2018}.
	\item 'The process by which dat ais extracted from data sources that are not optimized for analytics, moved to a central host and optimized for analytics', \textcite{Stich2019}.
	\item "A process that extracts the data from different database source systems, then transforms data and finally loads data into datawarehouse', \textcite{Guru2019}.
	\item 'The process of transferring data from soruce database to destination datawarehouse', \textcite{Naveen2016}.
\end{itemize}
Uit bovenstaande definities kan er afgeleid worden dat ETL gebruikt wordt om data te verzamelen, te transformeren en dan in een andere databank te steken. De data wordt geanalyseerd om de business een beter beeld te geven van de real-time gebeurtenissen bij bijvoorbeeld marketing om te weten wat het meest verkocht wordt om 12uur 's middags. 
Het proces dat ervoor zorgt dat de verzamelde data analyseerbaar is, bevat drie stappen.
De eerste stap is 'extraction', de data ophalen. De verzamelde data komt niet van één databank. Ze wordt opgehaald uit verschillende bronnen. Die bronnen zijn databanken die online informatie bevatten over het gedrag van die klant/gebruiker. Het verzamelen van die data mag de werking van de originele databank niet beïnvloeden.
Eens alle data verzameld is, wordt die getransformeerd en gefilterd om enkel de nodige data te gebruiken. Er wordt meer data verzameld dan nodig. De data wordt gefilterd aan de hand van regels opgesteld door de business. 
Hierna blijft enkel de hoognodige data over. Die data wordt ingelanden in een datawarehouse. Een datawarehouse is een databank waar men data analyseerd en logica op los laat. De business legt op welke analyse er moet gebeuren. De uitkomst van deze analyse kan gebruikt worden binnen het bedrijf of kan gebruikt worden voor artificiële intelligentie.  

\begin{figure}[h!]
	\includegraphics[width=10cm]{etl.PNG}
	\centering
	\caption{Hoe het ETL proces eruit ziet. \textcite{Panolapy2019}}
\end{figure}

\subsection{REST}
REST, of te wel 'REpresentational State Transfer', is een soort architectuur om web services te ontwikkelen. In volgende opsomming bevat verschillende definities omtrent REST:
\begin{itemize}
	\item 'REST is an architectal style, or design pattern, for API's', \textcite{Avraham2017}.
	\item 'REST API defines a set of functions which developers can perform requests via HTTP protocol', \textcite{Deering2012}.
	\item 'REST is architectural style for developing web services', \textcite{Rouse2019}.
	\item 'REST essentially refers to a style of web architecture that has many underlying characteristics and governs the behavoir of clients and servers', \textcite{Deering2012}.
\end{itemize}

Anders verwoordt: REST wordt geimplementeerd op al bestaande systemen om informatie op te halen. 
Enkele termen:
\begin{itemize}
	\item Client: Een persoon, software of web browser dat een API gebruikt.
	\item Resource: Het is een object dat de API informatie kan voor verlenen.
\end{itemize}

Enkele voordelen van REST:
\begin{itemize}
	\item REST is niet gebonden aan een programmeertaal.
	\item REST kan gebruikt worden in met elk protocol.
	\item REST laat toe om de requirements van beide kanten te implementeren. 
\end{itemize}

Enkele nadelen van REST:
\begin{itemize}
	\item REST wordt gelimiteerd door de tekortkomingen van HTTP.
	\item De informatie kan verloren gaan in de request-response cycle.
	\item Er kunnen geen notificaties gestuurd worden van de server naar de client.
	\item Iets dat REST-based is, komt meestal vaag over.
\end{itemize} 

\begin{figure}[h!]
	\includegraphics[width=10cm]{rest.jpg}
	\centering
	\caption{Hoe REST eruit ziet. \textcite{stSoftware2019tS}}
\end{figure}
\section{Order-to-cash proces in SAP}
\subsection{Definite}
\textcite{Wong2018} legt uit wat een order-to-cash proces inhoudt. Dit proces heeft veel invloed op het succes van een bedrijf. Dit proces heeft veel invloed met de klant. Een voordeel met de huidige technologie is dat het mogelijk is om het proces volledig te automatiseren. Dit zorgt voor een minimaal aantal fouten en vertragingen. De data en gegevens die worden opgehaald en geanalyseerd is correcter. 
Het proces begint bij het plaatsen van een order door de klant. Alles wat ervoor zorgt dat de klant een order plaatst behoort tot branding, marketing of sales. De hoofdactiviteit van deze afdelingen ligt bij customer relationship, iets wat plaatsvindt voor het OTC proces. Het maakt er geen deel van uit. 
Velen denken dat een OTC is afgerond wanneer de inning heeft plaatsgevonden. Maar er zijn nog belangrijke stappen die gebeuren na het innen van het geld. Onder andere de data die verzameld is tijdens het proces moet geanalyseerd worden om zo het proces te optimaliseren. 
\begin{figure}[h]
	\includegraphics[width=10cm]{wong.png}
	\caption{Het percentage van van bedrijven dat gebruik maken van order-to-cash proces. \textcite{Wong2018}}
	\centering
\end{figure}
Het OTC proces heeft invloed op volgende delen van het bedrijf:
\begin{itemize}
	\item Supply chaing management
	\item Voorraadbeheer
	\item Human resources
	\item Financiële afdeling
\end{itemize}
Zijn er problemen in één van die afdelingen, dan kan een vertraging in de andere afdelingen als gevolg hebben. Alsook een minder vlotte cashflow. 
Een goed OTC proces maakt indruk op de buiten wereld. Doordat het OTC goed gemanaged wordt, wordt er een beeld gecreërd dat het bedrijf stabiel is. 
Bij een OTC is technologie cruciaal. Elk deeltje van het proces kan beter worden door de nieuwe  technologie. Er zijn verschillende onderdelen nodig om het proces te optimaliseren om accurate en real-time informatie te verkrijgen. Zoals: 
\begin{itemize}
	\item Gegevens die onderling verbonden zijn.
	\item Automatisering
	\item digitale facturatie
	\item Digitale verzending van het management.
\end{itemize}

Volgende acht stappen komen voor in een OTC proces:
\begin{itemize}
	\item Order management
	\item Credit management
	\item Order fulfillment
	\item Order shipping
	\item Facturatie
	\item Accounts receivable
	\item Inning van het geld
	\item Rapportering en data management
\end{itemize}
In figuur 2.14 wordt het afgebeeld in een schema.
\begin{figure}[h]
	\includegraphics[width=10cm]{wong2.png}
	\caption{Het order-to-cash proces. \textcite{Wong2018}}
	\centering
\end{figure}
Order management is de eerste stap in het proces. Dit begint wanneer de klant een order plaatst. De manier waarop is niet zo belangrijk. Dit deeltje van het proces moet geautomatiseerd zijn. Bij het plaatsen van een order, moet er een ander onderdeel van het order proces getriggerd worden. Dit moet ervoor zorgen dat het order niet uit het oog verloren wordt. Door de automatisatie worden de andere deelnemende partijen direct ingelicht over het nieuwe  order en dit heeft een voordeel als het op tijdig leveren aankomt.
Hierna komt credit management. Dit moet ervoor zorgen dat er minder problemen zijn op het einde van het proces. Credit management houdt in dat men kijkt naar hoe het betalingsgedrag van de klant is geweest. Zijn er nog openstaande facturen, betaald de klant altijd maar na enkele aanmaningen? Door dit gedeelte te automatiseren, kan er bespaard worden op menskracht en geld. Als er toch dieper moet gekeken worden naar het betaalgedrag van een klant, kan dit doorgestuurd worden naar een  werknemer die er dan naar kijkt. Hierdoor moeten enkele klanten hun betaalgedrag gecontroleerd worden, i.d.p.v. alle klanten die een order plaatsen. 
De klanten die een goed betaalgedrag vertonen, worden doorgestuurd naar de volgende stap: Order fulfillment. In deze stap wordt het order ' echt samengesteld en uit de 'rekken' gehaald. Het is een groot voordeel als ' dit gedeelte geautomatiseerd is. Bij het verkopen van een product moet de voorraad automatisch aangepast worden. Eens de producten van het order samengebracht zijn gaat  men  over naar de volgende stap, order shipping. De verzending van de goederen. De verzending moet goed opgevolgd worden om mogelijke vertragingen te minimaliseren. De gegevens die vrijkomen bij een verzending, moeten zo snel mogelijk in het systeem worden ingegeven. Zodat dit deeltje van het proces geoptimaliseerd kan worden. 
Na het verzenden van de goederen komt de facturatie. Op dit deeltje heeft credit management veel invloed. Doordat de wanbetalers er in stap twee reeds zijn uitgehaald, zouden er hier minder problemen voorkomen. Wanneer hier fouten worden gemaakt, kan dit een sneeuwbal effect veroorzaken. Dit betekend dat één fout een andere fout kan triggeren en zo voorts. Het systeem moet de juiste info verkrijgen van de  werknemers. De info bevat meestal volgende puntjes:
\begin{itemize}
	\item Order specificaties
	\item De kosten
	\item Credit terms
	\item Order datum
	\item Verzendingsdatum
\end{itemize}
Deze punten moeten ingevoerd worden zodat het facturatiesysteem geautomatiseerd kan worden. Zodat hier vertragingen en fouten kunnen geminimaliseerd worden. Eens de factuur is uitgestuurd, wordt er een betaling verwacht binnen een bepaalde periode. Het systeem zou dit moeten bijhouden en ervoor zorgen dat er een melding gestuurd wordt nog voor de betalingsperiode is afgelopen. Dit valt onder de volgende stap accounts receivable. Deze stap probeert om te voorkomen dat mensen vergeten te betalen. 
De volgende stap is payment collections. Wordt een factuur niet betaald binnen de gevraagde periode dan wordt er een aanmaning gestuurd en wordt dit in het systeem bijgehouden. De  werknemers moeten de klanten contacteren zodat ze een reden kunnen geven voor het mogelijks vergeten van de betaling. 
Als laatste stap komt reporting en data management aan bod. Er bestaan programma's om ervoor te zorgen dat performance data over elk deeltje van het proces wordt opgehaald. Door achteraf deze data te gaan analyseren, kan er veel duidelijkheid komen van waar het verkeerd loopt. 

\textcite{PEARSON2017} beschrijft waarom het zo belangrijk is om een goed OTC proces te hebben. Vroeger waren de eisen van de klanten minder hoog. Als klanten iets bestellen, willen ze het de volgende dag al in huis hebben. Er zijn voor- en nadelen aan een OTC proces. Als het proces goed opgezet is, kan dit zorgen voor blijere klanten, minder wanbetalers, ... 

Is het order management proces niet goed opgezet, dan kan het heel snel slecht gaan. Klanten zullen niet tevreden zijn. 
Veel voorkomende redenen van ontevreden klanten:
\begin{itemize}
	\item Orders zitten er dubbel in.
	\item Er zit vertraging tussen de verschillende onderdelen van het proces.
	\item De levering klopt niet met wat er gefactureerd wordt.
	\item Een slecht voorraadbeheer waardoor niet aan de beloften zoals leveringstijd kan voldaan worden.
\end{itemize}
Om zulke problemen op te lossen moet men eerst gaan zoeken van waar die problemen komen. Automatisering is hier een goede oplossing voor. Dordaat verschillende processen aan elkaar gelinkt zijn, is er minder ruimte voor vertragingen. Enkele best practices omvatten:
\begin{itemize}
	\item Minimaliseren van  werknemers die handmatig gegevens moeten invullen.
	\item Klanten de mogelijkheid geven om hun bestellingen online te maken.
	\item Integratie van de informatie over het gehele proces.
	\item Elimineren van onnodige moeilijkheden binnen in het proces.
\end{itemize}

Het tweede subproces, bill-to-cash proces, heeft pitfalls en best practices.
In volgende opsomming komen verschillende signalen aan bod waaraan te zien is dat het bill-to-cash proces niet goed in elkaar zit.
\begin{itemize}
	\item Het aantal verkoopsovereenkomsten met speciale eisen van de klant is groot. Bijvoorbeeld: meer dan de helft heeft een uniek verkoopsovereenkomst.
	\item Herhalend aanbiedingen en toegevingen moeten doen door fouten in het proces.
	\item Wat op de oorspronkelijke offerte stond,  werd niet gefactureerd, er  werd meer aangerekend.
	\item Een groot aantal creditnota's uitgegeven.
	\item Tussen de verkoop, verzending en het facturerings proces kan er informatie ontbreken.
\end{itemize}
Om dit alles  weg te werken moet er goed gekeken worden naar waar de problemen nu zitten. Enkele best practices:
\begin{itemize}
	\item Integreer klantenprofielen in de betalingssoftware.
	\item Integreer de facturatie en betalingsgegevens met elkaar zodat op de factuur de juiste betalingsmethode staat.
\end{itemize}


\subsection{Technologie: Wat biedt SAP zelf aan voor microservices}

 Kyma is een recent project van SAP om toenadering te geven tot microserivces. Kyma is een open-source project gemaakt om Kubernetes. Kubernetes wordt gebruikt om applicaties op verschillende machines te managen. Je kan hiermee cloud-based applicaties en on-premise applicaties omzetten naar een microservice architectuur of naar serverless computing. Cloud-based applicaties zijn applicaties die hun data gaan ophalen over het internet in de plaats van op de harde schijf van de computer. On-premise applicaties zijn de tegenhangers van cloud-based. On-premise is lokaal op de computer, op de harde schijf. Serverless computing gebeurt in de cloud. Dit zorgt ervoor dat er op een dynamische manier de resources van een machine kan aangepast worden. 
Kyma zorgt voor betere end-to-end ervarings scenario's. Die volgen een best-practices voor performance, schaalbaarheid, efficentie en beveiliging. \textcite{Kyma2019}

Binnen SAP wordt er omgegaan met software van verschillende leveranciers. SAP probeert om hun software te customizen naar de  wensen van de klant. Dit vraagt meer openheid en een modernere architectuur. 
Het idee achter Kyma is het creëeren van serverless applicaties, mashups en microservices. ' kan het gebruikt worden om snel kleine, gecustomizede modules te developen. Die modules zijn dan verworven met business logica. 
Er  werd iets zoals Knative gemaakt. Knative is een platform dat developers ondersteund om serverless applicaties te maken op Kubernetes. Dit zorgde voor groot enthousiasme bij SAP omdat hun Kyma project een soort van bevesteging keer. Al snel  werd Kyma gerefactored om samen te kunnen  werken met Knative. Er  werden overlappende componenten  weggelaten, wat Kyma slanker en gestroomlijnder maakt. Dankzij Knative kan Kyma zich richten op higer-level enterprise applications en service consumption scenario's. En gebruik maken van Knative voor de infrastructuur en development scenario's. \textcite{Semerdzhiev2018}

 De samenwerking tussen Kyma en Knative is belangrijk. Er wordt een complete set van bouwblokken aangeboden en het zijn twee sterke frameworks. Bij het gebruik van beide kunnen er could-native oplossingen gebouwd worden op Kubernetes met een sterk framework. Op figuur 2.17 is te zien wat Kyma en wat Knative aanbiedt. \textcite{Hofmann2018}
\begin{figure}[h]
	\includegraphics[width=10cm]{1-kyma-knative.png}
	\caption{Wat Kyma, boven de lijn, aanbiedt en wat Knative, onder de lijn, aanbiedt \textcite{Hofmann2018}.}
	\centering
\end{figure}
De laatste maanden  werden de repositories gereconstrueerd en daarom zijn er geen tot  weinig referenties naar Knative. Naast die grote verandering  werd er gewerkt aan een proof-of-concept cloud-native oplossing door het gebruik van Knative en Kyma te samen. 

Kyma heeft hard gewerkt om deze problemen/uitdagingen te proberen  wegwerken. Kyma heeft geprobeerd om bedrijven te helpen met de transformatie naar digitalisatie. Kyma geeft bedrijven de mogelijkheid tot:
\begin{itemize}
	\item Be open and extendable: Kyma maakt gebruik van Open Service Broker API specificaties. Dit is een 'plug and play' die de mogelijkheid geeft om code te hergebruiken. Code van andere partijen te gebruiken. 
	\item Be seamlessly connected: Een eenvoudige manier om een beveiligde connectie te hebben tussen systemen. Deze kunnen gemanaged worden binnen de huidige applicatie om oplossingen te maken in hetrogene landschappen. Eén connectie geeft veel mogelijkheden.
	\item Use any programming language: Developers kunnen in hun gewenste programmeertaal coderen.
	\item Bring speed and agility: Er moet niet maanden gewacht worden om use cases of functionaliteiten op te leveren. 
	\item Accelerate innovation: Meestal start dit als een test of een trail. Bij zulke scenario's zijn de kost en de snelheid van zeer groot belang. Dankzij Kyma kunnen bedrijven meteen beginnen werken aan een oplossingen en moet er geen tijd besteed worden aan het zoeken van de best mogelijke oplossing. 
\end{itemize}


\section{Requirements van de business}
\textcite{Biedron2018} legt uit wat een order to cash proces is. Daaruit kunnen volgende requirements uit afgeleid worden:
\begin{itemize}
	\item De klant moet een order of meerdere orders kunnen plaatsen. Een goed werkend order-systeem is een must.
	\item Het order ophalen uit de voorraad. Er moet een goed voorraad beheer aanwezig zijn. Dit moet ervoor zorgen dat het aantal laattijdige leveringen geminimaliseerd wordt. Samen met het goede voorraadbeheer wordt ' best bijgehouden waar men goederen geplaatst heeft in het magazijn.
	\item De levering moet goed gepland worden. Dit zou voor het grootste deel al geautomatiseerd moeten zijn. Een email met informatie over de levering is een must. 
	\item Aanmaken van een factuur op basis van het geplaatst order met de juiste klantgegevens zou een geautmatiseerd onderdeel moeten zijn. 
	\item De betaling van de factuur komt toe in de financiele afdeling. Automatische afhandeling is een must.
\end{itemize}
Bij een order plaatsen komen volgende elementen aanbod:
\begin{itemize}
	\item Er moet een lijst met producten beschikbaar zijn.
	\item De klant zijn gegevens moeten gekend zijn bij het bedrijf.
	\item Het systeem bij het bedrijf moet beschikbaar zijn.
\end{itemize}
Na het plaatsen van het order die ' klaargezet worden om te leveren. Daar zijn volgende elementen van belang:
\begin{itemize}
	\item Een goed voorraadbeheer is de eerste must.
	\item Een overzicht van waar alles staat, geeft een meerwaarde.
	\item Bij het ophalen van een product om bij een order te plaatsen, moet de hoeveelheid in de voorraad verminderen.
\end{itemize}
